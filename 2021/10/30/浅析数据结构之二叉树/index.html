<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>浅析数据结构之二叉树 [ 云息未来 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
  
  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
    <script id="leancloud">
      AV.init({
          appId: "6E5zTbTljdUbVW2WkXPsXGJk-gzGzoHsz",
          appKey: "0vsyDKfNpeSECAI70J794ugv"
      });
    </script>

<meta name="generator" content="Hexo 5.4.1"></head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/fly.png"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">Home</a>
        
          
          
          
          
          
          
          <a href="/archives">Archives</a>
        
          
          
          
          
          
          
          <a href="/about">About</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">浅析数据结构之二叉树</h1>
<article class="post markdown-style">
  <h1 id="二叉树简介"><a href="#二叉树简介" class="headerlink" title="二叉树简介"></a>二叉树简介</h1><p>二叉树是由n（n&gt;=0）个结点组成的有序集合，集合或者为空，或者是由一个根节点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。</p>
<p><strong>二叉树的五种形态</strong></p>
<p><img src="http://image.immertry.top/201810311.png"></p>
<p><strong>二叉树的存储结构模型</strong></p>
<p>树的另一种表示法：孩子兄弟表示法<br>A、每个结点都有一个指向其第一个孩子的指针<br>B、每个结点都有一个指向其第一个右兄弟的指针</p>
<p><img src="http://image.immertry.top/201810312.png"></p>
<p>孩子兄弟表示法的特性：<br>A、能够表示任意的树形结构<br>B、每个结点包含一个数据成员和两个指针成员<br>C、孩子结点指针和兄弟结点指针构成树杈</p>
<p><strong>满二叉树</strong></p>
<p>如果二叉树中所有分支结点的度数都为2，并且叶子结点都在统一层次上，则二叉树为满二叉树。</p>
<p><img src="http://image.immertry.top/201810313.png"></p>
<p><strong>完全二叉树</strong></p>
<p>如果一棵具有n个结点的高度为k的二叉树，树的每个结点都与高度为k的满二叉树中编号为1——n的结点一一对应，则二叉树为完全二叉树。<br>完全二叉树的特性：<br>A、同样结点数的二叉树，完全二叉树的高度最小<br>B、完全二叉树的叶子结点仅出现在最下边两层，并且最底层的叶子结点一定出现在左边，倒数第二层的叶子结点一定出现在右边。<br>C、完全二叉树中度为1的结点只有左孩子。</p>
<p><img src="http://image.immertry.top/201810314.png"></p>
<p><strong>二叉树的特性</strong></p>
<p>A、在二叉树的第i层上最多有2^(i-1)个结点（i&gt;=1）。<br>B、高度为k的二叉树，最多有2^k-1个结点（k&gt;=0）。<br>C、对任何一棵二叉树，如果其叶结点有n个，度为2的非叶子结点有m个，则<br>n = m + 1。<br>D、具有n个结点的完全二叉树的高度为logn + 1<br>E、对于有n个结点的完全二叉树，按层次对结点进行编号（从上到下，从左到右），对于任意编号为i的结点</p>
<p><img src="http://image.immertry.top/201810315.png"></p>
<h1 id="二叉树的操作"><a href="#二叉树的操作" class="headerlink" title="二叉树的操作"></a>二叉树的操作</h1><p><strong>二叉树的存储结构实现</strong></p>
<p><img src="http://image.immertry.top/201810316.png"></p>
<p>二叉树结点包含四个固定的成员：结点的数据域、指向父结点的指针域、指向左子结点的指针域、指向右子结点的指针域。结点的数据域、指向父结点的指针域从TreeNode模板类继承而来。<br>二叉树结点的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  template &lt;typename T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BTreeNode</span>:<span class="keyword">public</span> TreeNode&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  BTreeNode&lt;T&gt;* m_left;<span class="comment">//左子结点</span></span><br><span class="line">  BTreeNode&lt;T&gt;* m_right;<span class="comment">//右子结点</span></span><br><span class="line">  BTreeNode()</span><br><span class="line">  &#123;</span><br><span class="line">      m_left = NULL;</span><br><span class="line">      m_right = NULL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//工厂方法，创建堆空间的结点</span></span><br><span class="line">  <span class="keyword">static</span> BTreeNode&lt;T&gt;* NewNode()</span><br><span class="line">  &#123;</span><br><span class="line">    BTreeNode&lt;T&gt;* ret = <span class="keyword">new</span> <span class="title class_">BTreeNode</span>&lt;T&gt;();</span><br><span class="line">    <span class="keyword">if</span>(ret != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//堆空间的结点标识为true</span></span><br><span class="line">        ret-&gt;m_flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>二叉树的结点查找</strong></p>
<p>A、基于数据元素的查找<br>定义基于数据元素查找的函数</p>
<p><img src="http://image.immertry.top/201810317.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">virtual BTreeNode&lt;T&gt;* find(BTreeNode&lt;T&gt;* node, const T&amp; value)const</span><br><span class="line">      &#123;</span><br><span class="line">          BTreeNode&lt;T&gt;* ret = NULL;</span><br><span class="line">          <span class="comment">//如果根节点node</span></span><br><span class="line">          <span class="keyword">if</span>(node != NULL)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(node-&gt;value == value)</span><br><span class="line">              &#123;</span><br><span class="line">                  ret = node;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">//查找左子树</span></span><br><span class="line">                  <span class="keyword">if</span>(ret == NULL)</span><br><span class="line">                  &#123;</span><br><span class="line">                      ret = find(node-&gt;m_left, value);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//如果左子树没有找到，ret返回NULL，查找右子树</span></span><br><span class="line">                  <span class="keyword">if</span>(ret == NULL)</span><br><span class="line">                  &#123;</span><br><span class="line">                      ret = find(node-&gt;m_right, value);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    BTreeNode&lt;T&gt;* find(const T&amp; value)const</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> find(root(), value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>B、基于结点的查找<br>定义基于结点查找的函数</p>
<p><img src="http://image.immertry.top/201810318.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">virtual BTreeNode&lt;T&gt;* find(BTreeNode&lt;T&gt;* node, BTreeNode&lt;T&gt;* obj)const</span><br><span class="line">      &#123;</span><br><span class="line">          BTreeNode&lt;T&gt;* ret = NULL;</span><br><span class="line">          <span class="keyword">if</span>(node != NULL)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//根节点node为目标结点</span></span><br><span class="line">              <span class="keyword">if</span>(node == obj)</span><br><span class="line">              &#123;</span><br><span class="line">                  ret = node;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">//查找左子树</span></span><br><span class="line">                  <span class="keyword">if</span>(ret == NULL)</span><br><span class="line">                  &#123;</span><br><span class="line">                      ret = find(node-&gt;m_left, obj);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//如果左子树没有找到，ret返回NULL，继续查找右子树</span></span><br><span class="line">                  <span class="keyword">if</span>(ret == NULL)</span><br><span class="line">                  &#123;</span><br><span class="line">                      ret = find(node-&gt;m_right, obj);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">    BTreeNode&lt;T&gt;* find(TreeNode&lt;T&gt;* node)const</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> find(root(), dynamic_cast&lt;BTreeNode&lt;T&gt;*&gt;(node));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>二叉树的结点插入</strong></p>
<p>根据插入的位置定义二叉树结点的位置枚举类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">BTNodePos</span></span><br><span class="line">   &#123;</span><br><span class="line">       Any,</span><br><span class="line">       Left,</span><br><span class="line">       Right</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<p>在node结点的pos位置插入newnode结点的功能函数如下：</p>
<p><img src="http://image.immertry.top/201810319.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">virtual bool <span class="title function_">insert</span><span class="params">(BTreeNode&lt;T&gt;* newnode, BTreeNode&lt;T&gt;* node, BTNodePos pos)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="type">bool</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">//插入的位置为Any</span></span><br><span class="line">          <span class="keyword">if</span>(pos == Any)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//如果没有左子结点，插入结点作为左子结点</span></span><br><span class="line">              <span class="keyword">if</span>(node-&gt;m_left == NULL)</span><br><span class="line">              &#123;</span><br><span class="line">                  node-&gt;m_left = newnode;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//如果有左子结点，没有右子结点，插入结点作为右子结点</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;m_right == NULL)</span><br><span class="line">              &#123;</span><br><span class="line">                  node-&gt;m_right = newnode;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//如果node结点的左右子结点不为空，插入失败</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  ret = <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(pos == Left)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//如果指定插入左子结点，如果没有左子结点，插入结点</span></span><br><span class="line">              <span class="keyword">if</span>(node-&gt;m_left == NULL)</span><br><span class="line">              &#123;</span><br><span class="line">                  node-&gt;m_left = newnode;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  ret = <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(pos == Right)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//如果指定插入右子结点，如果没有右子结点，插入结点</span></span><br><span class="line">              <span class="keyword">if</span>(node-&gt;m_right == NULL)</span><br><span class="line">              &#123;</span><br><span class="line">                  node-&gt;m_right = newnode;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  ret = <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              ret = <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>A、插入新结点</p>
<p><img src="http://image.immertry.top/2018103110.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入结点，无位置要求</span></span><br><span class="line">   bool <span class="title function_">insert</span><span class="params">(TreeNode&lt;T&gt;* node)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> insert(dynamic_cast&lt;BTreeNode&lt;T&gt;*&gt;(node), Any);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//插入结点，指定插入位置</span></span><br><span class="line">   virtual bool <span class="title function_">insert</span><span class="params">(BTreeNode&lt;T&gt;* node, BTNodePos pos)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">bool</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">if</span>(node != NULL)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(<span class="built_in">this</span>-&gt;m_root == NULL)</span><br><span class="line">           &#123;</span><br><span class="line">               node-&gt;parent = NULL;</span><br><span class="line">               <span class="built_in">this</span>-&gt;m_root = node;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">              BTreeNode&lt;T&gt;* np = find(node-&gt;parent);</span><br><span class="line">              <span class="keyword">if</span>(np != NULL)</span><br><span class="line">              &#123;</span><br><span class="line">                  ret = insert(dynamic_cast&lt;BTreeNode&lt;T&gt;*&gt;(node), np, pos);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  THROW_EXCEPTION(InvalidParameterException, <span class="string">&quot;Parameter invalid...&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           THROW_EXCEPTION(InvalidParameterException, <span class="string">&quot;Parameter invalid...&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>B、插入数据元素</p>
<p><img src="http://image.immertry.top/2018103111.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入数据，指定插入位置和父结点</span></span><br><span class="line">   virtual bool <span class="title function_">insert</span><span class="params">(const T&amp; value, TreeNode&lt;T&gt;* parent, BTNodePos pos)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">bool</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">       BTreeNode&lt;T&gt;* node = BTreeNode&lt;T&gt;::NewNode();</span><br><span class="line">       <span class="keyword">if</span>(node != NULL)</span><br><span class="line">       &#123;</span><br><span class="line">           node-&gt;parent = parent;</span><br><span class="line">           node-&gt;value = value;</span><br><span class="line">           ret = insert(node, pos);</span><br><span class="line">           <span class="keyword">if</span>(!ret)</span><br><span class="line">           &#123;</span><br><span class="line">               delete node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           THROW_EXCEPTION(NoEnoughMemoryException, <span class="string">&quot;No enough memory...&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//插入数据，指定父结点</span></span><br><span class="line">   bool <span class="title function_">insert</span><span class="params">(const T&amp; value, TreeNode&lt;T&gt;* parent)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> insert(value, parent, Any);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉树的结点删除</strong></p>
<p>删除功能函数的定义：</p>
<p><img src="http://image.immertry.top/2018103112.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(BTreeNode&lt;T&gt;* node, BTree&lt;T&gt;* ret)</span></span><br><span class="line">      &#123;</span><br><span class="line">          ret = <span class="keyword">new</span> <span class="title class_">BTree</span>&lt;T&gt;();</span><br><span class="line">          <span class="keyword">if</span>(ret == NULL)</span><br><span class="line">          &#123;</span><br><span class="line">              THROW_EXCEPTION(NoEnoughMemoryException, <span class="string">&quot;No enough memory...&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(node == root())</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="built_in">this</span>-&gt;m_root = NULL;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  BTreeNode&lt;T&gt;* parent = dynamic_cast&lt;BTreeNode&lt;T&gt;*&gt;(node-&gt;parent);</span><br><span class="line">                  <span class="keyword">if</span>(parent-&gt;m_left == node)</span><br><span class="line">                  &#123;</span><br><span class="line">                      parent-&gt;m_left = NULL;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(parent-&gt;m_right == node)</span><br><span class="line">                  &#123;</span><br><span class="line">                      parent-&gt;m_right = NULL;</span><br><span class="line">                  &#125;</span><br><span class="line">                  node-&gt;parent = NULL;</span><br><span class="line">              &#125;</span><br><span class="line">              ret-&gt;m_root = node;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>A、基于数据元素值删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据数据元素删除结点</span></span><br><span class="line">   SharedPointer&lt; Tree&lt;T&gt; &gt; remove(const T&amp; value)</span><br><span class="line">   &#123;</span><br><span class="line">       BTree&lt;T&gt;* ret = NULL;</span><br><span class="line">       BTreeNode&lt;T&gt;* node = find(value);</span><br><span class="line">       <span class="keyword">if</span>(node == NULL)</span><br><span class="line">       &#123;</span><br><span class="line">           THROW_EXCEPTION(InvalidParameterException, <span class="string">&quot;No value...&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           remove(node, ret);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>B、基于结点删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据结点删除结点</span></span><br><span class="line">   SharedPointer&lt; Tree&lt;T&gt; &gt; remove(TreeNode&lt;T&gt;* node)</span><br><span class="line">   &#123;</span><br><span class="line">       BTree&lt;T&gt;* ret = NULL;</span><br><span class="line">       node = find(node);</span><br><span class="line">       <span class="keyword">if</span>(node != NULL)</span><br><span class="line">       &#123;</span><br><span class="line">           remove(dynamic_cast&lt;BTreeNode&lt;T&gt;*&gt;(node), ret);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           THROW_EXCEPTION(InvalidParameterException, <span class="string">&quot;No node...&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉树的清空</strong></p>
<p>将二叉树中所有在堆空间分配的结点销毁。<br>清除node结点为根节点的二叉树的功能函数：</p>
<p><img src="http://image.immertry.top/2018103113.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(BTreeNode&lt;T&gt;* node)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(node != NULL)</span><br><span class="line">          &#123;</span><br><span class="line">              free(node-&gt;m_left);</span><br><span class="line">              free(node-&gt;m_right);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果结点在堆空间分配</span></span><br><span class="line">          <span class="keyword">if</span>(node-&gt;flag())</span><br><span class="line">          &#123;</span><br><span class="line">              delete node;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//清空树</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        free(root());</span><br><span class="line">        <span class="built_in">this</span>-&gt;m_root = NULL;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>二叉树的属性操作</strong></p>
<p>A、树中结点的数量<br>定义计算某个结点为根结点的树的结点的数量</p>
<p><img src="http://image.immertry.top/2018103114.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(BTreeNode&lt;T&gt;* node)</span> const</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span>(node != NULL)</span><br><span class="line">          &#123;</span><br><span class="line">              ret = count(node-&gt;m_left) + count(node-&gt;m_right) + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//树的结点数目访问函数</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>const</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> count(root());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>B、树的高度<br>获取node结点为根结点的二叉树的高度的功能函数：</p>
<p><img src="http://image.immertry.top/2018103115.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">height</span><span class="params">(BTreeNode&lt;T&gt;* node)</span> const</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span>(node != NULL)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> height(node-&gt;m_left);</span><br><span class="line">              <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> height(node-&gt;m_right);</span><br><span class="line">              ret = ((l &gt; r)?l:r) + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//树的高度访问函数</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">height</span><span class="params">()</span>const</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> height(root());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>C、树的度<br>获取node为根结点的二叉树的度的功能函数：</p>
<p><img src="http://image.immertry.top/2018103116.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">degree</span><span class="params">(BTreeNode&lt;T&gt;* node)</span> const</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span>(node != NULL)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//根结点的度数</span></span><br><span class="line">              ret = (!!node-&gt;m_left + !!node-&gt;m_right);</span><br><span class="line">              <span class="comment">//左子树的度</span></span><br><span class="line">              <span class="keyword">if</span>(ret &lt; <span class="number">2</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> degree(node-&gt;m_left);</span><br><span class="line">                  <span class="keyword">if</span>(ret &lt; l)</span><br><span class="line">                  &#123;</span><br><span class="line">                      ret = l;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//右子树的度数</span></span><br><span class="line">              <span class="keyword">if</span>(ret &lt; <span class="number">2</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> degree(node-&gt;m_left);</span><br><span class="line">                  <span class="keyword">if</span>(ret &lt; r)</span><br><span class="line">                  &#123;</span><br><span class="line">                      ret = r;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//树的度访问函数</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">degree</span><span class="params">()</span>const</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> degree(root());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉树的层次遍历</strong></p>
<p>二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问依次，且仅被访问一次。<br>根据游标思想，提供一组遍历的先关函数，按层次访问二叉树中的数据元素。</p>
<p><img src="http://image.immertry.top/2018103117.png"></p>
<p>引入一个队列，辅助遍历二叉树。<br>LinkedQueue&lt;BTreeNode<T>*&gt; m_queue;<br>层次遍历的过程如下：</p>
<p><img src="http://image.immertry.top/2018103118.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将根结点压入队列</span></span><br><span class="line">   bool <span class="title function_">begin</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">ret</span> <span class="operator">=</span> (root() != NULL);</span><br><span class="line">     <span class="keyword">if</span>(ret)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//清空队列</span></span><br><span class="line">         m_queue.clear();</span><br><span class="line">         <span class="comment">//根节点加入队列</span></span><br><span class="line">         m_queue.add(root());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//判断队列是否为空</span></span><br><span class="line">   bool <span class="title function_">end</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> (m_queue.length() == <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//队头元素弹出，将队头元素的孩子压入队列中</span></span><br><span class="line">   bool <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">ret</span> <span class="operator">=</span> (m_queue.length() &gt; <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">if</span>(ret)</span><br><span class="line">     &#123;</span><br><span class="line">         BTreeNode&lt;T&gt;* node = m_queue.front();</span><br><span class="line">         m_queue.remove();<span class="comment">//队头元素出队</span></span><br><span class="line">         <span class="comment">//将队头元素的子结点入队</span></span><br><span class="line">         <span class="keyword">if</span>(node-&gt;m_left != NULL)</span><br><span class="line">         &#123;</span><br><span class="line">             m_queue.add(node-&gt;m_left);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(node-&gt;m_right != NULL)</span><br><span class="line">         &#123;</span><br><span class="line">             m_queue.add(node-&gt;m_right);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//访问队头元素指向的数据元素</span></span><br><span class="line">   T <span class="title function_">current</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span>(!end())</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> m_queue.front()-&gt;value;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         THROW_EXCEPTION(InvalidOperationException, <span class="string">&quot;No value at current Node...&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉树的克隆</strong></p>
<p>定义克隆node结点为根结点的二叉树的功能函数：</p>
<p><img src="http://image.immertry.top/2018103119.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">BTreeNode&lt;T&gt;* clone(BTreeNode&lt;T&gt;* node)</span><br><span class="line">      &#123;</span><br><span class="line">          BTreeNode&lt;T&gt; * ret = NULL;</span><br><span class="line">          <span class="keyword">if</span>(node != NULL)</span><br><span class="line">          &#123;</span><br><span class="line">              ret = BTreeNode&lt;T&gt;::NewNode();</span><br><span class="line">              <span class="keyword">if</span>(ret != NULL)</span><br><span class="line">              &#123;</span><br><span class="line">                  ret-&gt;value = node-&gt;value;</span><br><span class="line">                  <span class="comment">//左子树</span></span><br><span class="line">                  ret-&gt;m_left = clone(node-&gt;m_left);</span><br><span class="line">                  <span class="comment">//右子树</span></span><br><span class="line">                  ret-&gt;m_right = clone(node-&gt;m_right);</span><br><span class="line">                  <span class="comment">//如果左子树不为空，设置左子树的父结点</span></span><br><span class="line">                  <span class="keyword">if</span>(ret-&gt;m_left != NULL)</span><br><span class="line">                  &#123;</span><br><span class="line">                      ret-&gt;m_left-&gt;parent = ret;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//如果右子树不为空，设置右子树父结点</span></span><br><span class="line">                  <span class="keyword">if</span>(ret-&gt;m_right != NULL)</span><br><span class="line">                  &#123;</span><br><span class="line">                      ret-&gt;m_right-&gt;parent = ret;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  THROW_EXCEPTION(NoEnoughMemoryException, <span class="string">&quot;No enough memory...&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">    SharedPointer&lt;BTreeNode&lt;T&gt;&gt; <span class="title function_">clone</span><span class="params">()</span>const</span><br><span class="line">    &#123;</span><br><span class="line">        BTree&lt;T&gt;* ret = <span class="keyword">new</span> <span class="title class_">BTree</span>&lt;T&gt;();</span><br><span class="line">        <span class="keyword">if</span>(ret != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            ret-&gt;m_root = clone(root());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            THROW_EXCEPTION(NoEnoughMemoryException, <span class="string">&quot;No enough memory...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉树的比较</strong></p>
<p>判断两棵二叉树中的数据元素是否对应相等<br>定义二叉树相等比较的功能函数：</p>
<p><img src="http://image.immertry.top/2018103120.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bool <span class="title function_">equal</span><span class="params">(BTreeNode&lt;T&gt;* l, BTreeNode&lt;T&gt;* r)</span>const</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="type">bool</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">//二叉树自比较</span></span><br><span class="line">          <span class="keyword">if</span>(l == r)</span><br><span class="line">          &#123;</span><br><span class="line">              ret = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//两棵二叉树都不为空</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(l != NULL &amp;&amp;  r != NULL)</span><br><span class="line">          &#123;</span><br><span class="line">             ret = (l-&gt;value == r-&gt;value) &amp;&amp; (equal(l-&gt;m_left, r-&gt;m_left)) &amp;&amp; (l-&gt;m_right, r-&gt;m_right);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//有一棵二叉树为空，一棵二叉树不为空</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              ret = <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="variable">operator</span> <span class="operator">=</span>=(const BTree&lt;T&gt;&amp; tree)const</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> equal(root(), tree.root());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool operator !=(const BTree&lt;T&gt;&amp; tree)const</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="built_in">this</span> == tree);<span class="comment">//使用==比较</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉树的相加</strong></p>
<p>将当前二叉树与参数btree二叉树中对应的数据元素相加，返回一棵在堆空间创建的新的二叉树。<br>二叉树相加实例如下：</p>
<p><img src="http://image.immertry.top/2018103121.png"></p>
<p>定义将两棵二叉树相加的功能函数：</p>
<p><img src="http://image.immertry.top/2018103122.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">BTreeNode&lt;T&gt;* add(BTreeNode&lt;T&gt;* l, BTreeNode&lt;T&gt;* r)const</span><br><span class="line">      &#123;</span><br><span class="line">          BTreeNode&lt;T&gt;* ret = NULL;</span><br><span class="line">          <span class="comment">//二叉树l为空</span></span><br><span class="line">          <span class="keyword">if</span>(l == NULL &amp;&amp; r != NULL)</span><br><span class="line">          &#123;</span><br><span class="line">            ret = clone(r);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//二叉树r为空</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(l != NULL &amp;&amp; r == NULL)</span><br><span class="line">          &#123;</span><br><span class="line">            ret = clone(l);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//二叉树l和二叉树r不为空</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(l != NULL &amp;&amp; r != NULL)</span><br><span class="line">          &#123;</span><br><span class="line">              ret = BTreeNode&lt;T&gt;::NewNode();</span><br><span class="line">              <span class="keyword">if</span>(ret != NULL)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">//根节点数据元素相加</span></span><br><span class="line">                  ret-&gt;value = l-&gt;value + r-&gt;value;</span><br><span class="line">                  <span class="comment">//左子树相加</span></span><br><span class="line">                  ret-&gt;m_left = add(l-&gt;m_left, r-&gt;m_left);</span><br><span class="line">                  <span class="comment">//右子树相加</span></span><br><span class="line">                  ret-&gt;m_right = add(l-&gt;m_right, r-&gt;m_right);</span><br><span class="line">                  <span class="comment">//左子树不为空，设置左子树的父结点为当前结点</span></span><br><span class="line">                  <span class="keyword">if</span>(ret-&gt;m_left != NULL)</span><br><span class="line">                  &#123;</span><br><span class="line">                      ret-&gt;m_left-&gt;parent = ret;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//右子树不为空，设置右子树的父结点为当前结点</span></span><br><span class="line">                  <span class="keyword">if</span>(ret-&gt;m_right != NULL)</span><br><span class="line">                  &#123;</span><br><span class="line">                      ret-&gt;m_right-&gt;parent = ret;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  THROW_EXCEPTION(NoEnoughMemoryException, <span class="string">&quot;No enough memory...&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">        SharedPointer&lt;BTree&lt;T&gt;&gt; <span class="title function_">add</span><span class="params">(const BTree&lt;T&gt;&amp; other)</span>const</span><br><span class="line">    &#123;</span><br><span class="line">        BTree&lt;T&gt;* ret = <span class="keyword">new</span> <span class="title class_">BTree</span>&lt;T&gt;();</span><br><span class="line">        <span class="keyword">if</span>(ret != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            ret-&gt;m_root = add(root(), other.root());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            THROW_EXCEPTION(NoEnoughMemoryException, <span class="string">&quot;No enough memoty...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的典型遍历方式"><a href="#二叉树的典型遍历方式" class="headerlink" title="二叉树的典型遍历方式"></a>二叉树的典型遍历方式</h1><p>二叉树有先序、中序、后序三种遍历方式，三种遍历方法的不同主要是取决于根节点的遍历顺序。</p>
<p><strong>前序遍历</strong></p>
<p>如果二叉树为空，则无操作，直接返回。<br>如果二叉树非空，则执行以下操作：<br>A、访问根结点；<br>B、先序遍历左子树；<br>C、先序遍历右子树。<br>先序遍历实现代码：</p>
<p><img src="http://image.immertry.top/2018103123.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">preOrderTraversal</span><span class="params">(BTreeNode&lt;T&gt;* node, LinkedQueue&lt;BTreeNode&lt;T&gt;*&gt;&amp; queue)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span>(node != NULL)</span><br><span class="line">      &#123;</span><br><span class="line">          queue.add(node);</span><br><span class="line">          preOrderTraversal(node-&gt;m_left, queue);</span><br><span class="line">          preOrderTraversal(node-&gt;m_right, queue);</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>先序遍历二叉树示例：</p>
<p><img src="http://image.immertry.top/2018103124.png"></p>
<p><strong>中序遍历</strong></p>
<p>如果二叉树为空，则无操作，直接返回。<br>如果二叉树非空，则执行以下操作：<br>A、中序遍历左子树；<br>B、访问根结点；<br>C、中序遍历右子树。<br>中序遍历实现代码：</p>
<p><img src="http://image.immertry.top/2018103125.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(BTreeNode&lt;T&gt;* node, LinkedQueue&lt;BTreeNode&lt;T&gt;*&gt;&amp; queue)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(node != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">      inOrderTraversal(node-&gt;m_left, queue);</span><br><span class="line">      queue.add(node);</span><br><span class="line">      inOrderTraversal(node-&gt;m_right, queue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中序遍历二叉树示例：</p>
<p><img src="http://image.immertry.top/2018103126.png"></p>
<p><strong>后序遍历</strong></p>
<p>如果二叉树为空，则无操作，直接返回。<br>如果二叉树非空，则执行以下操作：<br>A、后序遍历左子树；<br>B、后序遍历右子树；<br>C、访问根结点。<br>后序遍历实现代码</p>
<p><img src="http://image.immertry.top/2018103127.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">postOrderTraversal</span><span class="params">(BTreeNode&lt;T&gt;* node, LinkedQueue&lt;BTreeNode&lt;T&gt;*&gt;&amp; queue)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(node != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">      postOrderTraversal(node-&gt;m_left, queue);</span><br><span class="line">      postOrderTraversal(node-&gt;m_right, queue);</span><br><span class="line">      queue.add(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后序遍历二叉树示例：</p>
<p><img src="http://image.immertry.top/2018103128.png"></p>
<p><strong>遍历算法的封装</strong></p>
<p>定义遍历方式的枚举类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">BTTraversal</span></span><br><span class="line">    &#123;</span><br><span class="line">        PreOder,</span><br><span class="line">        InOder,</span><br><span class="line">        PostOder</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>根据参数order选择遍历的方式，返回数组保存了二叉树遍历结点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">SharedPointer&lt;Array&lt;T&gt;&gt; <span class="title function_">traversal</span><span class="params">(BTTraversal order)</span></span><br><span class="line">   &#123;</span><br><span class="line">       DynamicArray&lt;T&gt;* ret = NULL;</span><br><span class="line">       LinkedQueue&lt;BTreeNode&lt;T&gt;*&gt; queue;<span class="comment">//保存遍历二叉树的结点</span></span><br><span class="line">       <span class="keyword">switch</span> (order)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">case</span> PreOder:</span><br><span class="line">               preOrderTraversal(root(), queue);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> InOder:</span><br><span class="line">               inOrderTraversal(root(), queue);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> PostOder:</span><br><span class="line">               postOrderTraversal(root(), queue);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               THROW_EXCEPTION(InvalidParameterException, <span class="string">&quot;Parameter invalid...&quot;</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       ret = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>&lt;T&gt;(queue.length());</span><br><span class="line">       <span class="keyword">if</span>(ret != NULL)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ret-&gt;length(); i++, queue.remove())</span><br><span class="line">           &#123;</span><br><span class="line">               ret-&gt;set(i, queue.front()-&gt;value);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           THROW_EXCEPTION(NoEnoughMemoryException, <span class="string">&quot;No enough memory...&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h1><p><strong>线索化二叉树</strong></p>
<p>线索化二叉树是将二叉树转换为双向链表的过程（将非线性的二叉树转换为线性的链表）。<br>二叉树的线索化能够反映某种二叉树的遍历次序（结点的先后访问次序）。<br>线索化二叉树的过程：</p>
<p><img src="http://image.immertry.top/2018103129.png"></p>
<p>二叉树线索化的实现：</p>
<p><img src="http://image.immertry.top/2018103130.png"></p>
<p>通过某种遍历方式遍历二叉树，根据遍历次序将二叉树结点依次存储到辅助队列中，最后将辅助队列中保存的结点依次出队并连接（连接时，原二叉树结点的m_left指针作为双向链表结点的m_prev指针，指向结点的前驱；原二叉树结点的m_right结点作为双向链表结点的m_next指针，指向结点的后继），成为双向链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(BTTraversal order, LinkedQueue&lt;BTreeNode&lt;T&gt;*&gt;&amp; queue)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">switch</span> (order)</span><br><span class="line">       &#123;</span><br><span class="line">       <span class="keyword">case</span> PreOrder:</span><br><span class="line">           preOrderTraversal(root(), queue);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> InOrder:</span><br><span class="line">           inOrderTraversal(root(), queue);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> PostOrder:</span><br><span class="line">           postOrderTraversal(root(), queue);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> LevelOrder:</span><br><span class="line">           levelOrderTraversal(root(), queue);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">           THROW_EXCEPTION(InvalidParameterException, <span class="string">&quot;Parameter invalid...&quot;</span>);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>层次遍历算法</strong></p>
<p>增加层次遍历方式LevelOrder到遍历方式枚举类型中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">BTTraversal</span></span><br><span class="line">&#123;</span><br><span class="line">    PreOrder,<span class="comment">//先序遍历</span></span><br><span class="line">    InOrder,<span class="comment">//中序遍历</span></span><br><span class="line">    PostOrder,<span class="comment">//后序遍历</span></span><br><span class="line">    LevelOrder<span class="comment">//层次遍历</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>层次遍历算法：<br>A、将根结点入队<br>B、访问队头元素指向的二叉树结点<br>C、将队头元素出队，队头元素的孩子入队<br>D、判断队列是否为空，如果非空，继续B；如果为空，结束。</p>
<p><img src="http://image.immertry.top/2018103131.png"></p>
<p>层次遍历二叉树的实例如下：</p>
<p><img src="http://image.immertry.top/2018103132.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">levelOrderTraversal</span><span class="params">(BTreeNode&lt;T&gt;* node, LinkedQueue&lt;BTreeNode&lt;T&gt;*&gt;&amp; queue)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//辅助队列</span></span><br><span class="line">            LinkedQueue&lt;BTreeNode&lt;T&gt;*&gt; temp;</span><br><span class="line">            <span class="comment">//根结点压入队列</span></span><br><span class="line">            temp.add(node);</span><br><span class="line">            <span class="keyword">while</span>(temp.length() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                BTreeNode&lt;T&gt;* n = temp.front();</span><br><span class="line">                <span class="comment">//如果左孩子不为空，将左孩子结点入队</span></span><br><span class="line">                <span class="keyword">if</span>(n-&gt;m_left != NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.add(n-&gt;m_left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果右孩子不为空，将右孩子结点入队</span></span><br><span class="line">                <span class="keyword">if</span>(n-&gt;m_right != NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.add(n-&gt;m_right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将队列的队头元素出队</span></span><br><span class="line">                temp.remove();</span><br><span class="line">                <span class="comment">//将队列的队头元素入队输出队列</span></span><br><span class="line">                queue.add(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>队列中结点的连接</strong></p>
<p>将队列中的所有结点连接成为一个线性的双向链表</p>
<p><img src="http://image.immertry.top/2018103133.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(LinkedQueue&lt;BTreeNode&lt;T&gt;*&gt;&amp; queue)</span></span><br><span class="line">    &#123;</span><br><span class="line">        BTreeNode&lt;T&gt;* ret = NULL;</span><br><span class="line">        <span class="keyword">if</span>(queue.length() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//返回队列的队头元素指向的结点作为双向链表的首结点</span></span><br><span class="line">            ret = queue.front();</span><br><span class="line">            <span class="comment">//双向链表的首结点的前驱设置为空</span></span><br><span class="line">            ret-&gt;m_left = NULL;</span><br><span class="line">            <span class="comment">//创建一个游标结点，指向队列队头</span></span><br><span class="line">            BTreeNode&lt;T&gt;* slider = queue.front();</span><br><span class="line">            <span class="comment">//将队头元素出队</span></span><br><span class="line">            queue.remove();</span><br><span class="line">            <span class="keyword">while</span>(queue.length() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//当前游标结点的后继指向队头元素</span></span><br><span class="line">                slider-&gt;m_right = queue.front();</span><br><span class="line">                <span class="comment">//当前队头元素的前驱指向当前游标结点</span></span><br><span class="line">                queue.front()-&gt;m_left = slider;</span><br><span class="line">                <span class="comment">//将当前游标结点移动到队头元素</span></span><br><span class="line">                slider = queue.front();</span><br><span class="line">                <span class="comment">//将当前队头元素出队，继续处理新的队头元素</span></span><br><span class="line">                queue.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//双向链表的尾结点的后继为空</span></span><br><span class="line">            slider-&gt;m_right = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>线索化二叉树的实现</strong></p>
<p>线索化二叉树函数接口的设计：<br>BTreeNode<T>* thread(BTTraversal order)<br>A、根据参数order选择线索化的方式（先序、中序、后序、层次）<br>B、返回值是线索化二叉树后指向链表首结点的指针<br>C、线索化二叉树后，原有的二叉树被破坏，二叉树的所有结点根据遍历次序组建为一个线性的双向链表，对应的二叉树应为空。<br>线索化二叉树的流程：</p>
<p><img src="http://image.immertry.top/2018103134.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BTreeNode&lt;T&gt;* thread(BTTraversal order)</span><br><span class="line">   &#123;</span><br><span class="line">       BTreeNode&lt;T&gt;* ret = NULL;</span><br><span class="line">       LinkedQueue&lt;BTreeNode&lt;T&gt;*&gt;* queue;</span><br><span class="line">       <span class="comment">//遍历二叉树，并按遍历次序将结点保存到队列</span></span><br><span class="line">       traversal(order, queue);</span><br><span class="line">       <span class="comment">//连接队列中的结点成为双向链表</span></span><br><span class="line">       ret = connect(queue);</span><br><span class="line">       <span class="comment">//将二叉树的根节点置空</span></span><br><span class="line">       <span class="built_in">this</span>-&gt;m_root = NULL;</span><br><span class="line">       <span class="comment">//将游标遍历的辅助队列清空</span></span><br><span class="line">       m_queue.clear();</span><br><span class="line">       <span class="comment">//返回双向链表的首结点</span></span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>文章转载自 <a target="_blank" rel="noopener" href="http://blog.51cto.com/9291927/2083190">http://blog.51cto.com/9291927/2083190</a></p>
</blockquote>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="/2021/11/02/%E4%BD%BF%E7%94%A8Sublime-Text3%E7%BC%96%E5%86%99html%E9%A1%B5%E9%9D%A2/">prev</a>
    

    
    <p>last update time 2022-02-26</p>
    
    
        <a class="extend next post-next" href="/2021/10/29/java%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/">next</a>
    
    </div>


    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:immertry@163.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/ImmerTry" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
				
				<li>
					<a href="https://weibo.com/u/5092233560?display=0&amp;retcode=6102" title="weibo" target="_self">
					<i class="fa fa-weibo"></i>
					</a>
				</li>
			
		
			
		
			
				
				<li>
					<a href="https://www.zhihu.com/people/liu-lei-62-41" title="zhihu" target="_self">
					<i class="fa fa-zhihu"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © 云息未来 2021 - 2022
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>
    </div>
</body>
</html>
